{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{323:function(e,t,n){\"use strict\";n.r(t);var a=n(0),r=n.n(a),l=n(116),o=n(122),i=n(124),c=n(322),s=n(123),m=n(63),u=n(43),p=n(32),h=function(e){var t,n,a,r,l=(t=document.querySelector(\".hljs-comment\"))&&\"none\"===t.style.display?e.map((function(e){return e.split(\"//\")[0]})):e;n=l.join(\"\\n\"),a=document.documentElement.scrollTop||document.body.scrollTop,(r=document.createElement(\"textarea\")).value=n,document.body.appendChild(r),r.focus(),r.select(),document.execCommand(\"copy\"),document.body.removeChild(r),scroll(0,a)},f=n(36);function d(){return(d=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function b(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function E(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function x(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||\"[object Arguments]\"===Object.prototype.toString.call(e)))return;var n=[],a=!0,r=!1,l=void 0;try{for(var o,i=e[Symbol.iterator]();!(a=(o=i.next()).done)&&(n.push(o.value),!t||n.length!==t);a=!0);}catch(e){r=!0,l=e}finally{try{a||null==i.return||i.return()}finally{if(r)throw l}}return n}(e,t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()}var g=function(e){var t=e.language,n=e.fileName,l=e.lines,o=Object(a.useContext)(u.CodeStyleContext),i=x(Object(a.useContext)(u.CodeDataContext),2),g=i[0],y=i[1],w=Object(a.useContext)(m.a),v=x(Object(a.useState)(!1),2),O=v[0],j=v[1];if(void 0===g[n])return y(n,w),r.a.createElement(p.b,null);var I=x(l,2),M=I[0],B=I[1],S=g[n].slice(M-1,B),C=Object(f.c)(o.style),z=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?b(n,!0).forEach((function(t){E(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):b(n).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},f.a,{fontSize:o.fontSize});return r.a.createElement(r.a.Fragment,null,r.a.createElement(s.a,{anchorOrigin:{vertical:\"bottom\",horizontal:\"left\"},open:O,autoHideDuration:6e3,onClose:function(){return j(!1)},message:r.a.createElement(\"span\",null,\"Code copied to clipboard ;)\")}),r.a.createElement(c.a,d({customStyle:z,language:t,style:C},{onDoubleClick:function(){j(!0),h(S)}}),S.join(\"\\n\")))};function y(){var e=v([\"\\n            x^n = \\n            \\begin{cases}\\n            (x^2)^{space \\frac{n}{2}}           & \\text{if n is even}  \\\\\\n            x space (x^2)^{space \\frac{n-1}{2}}    & \\text{if n is odd}   \\\\\\n            end{cases}\\n        \"],[\"\\n            x^n = \\n            \\\\begin{cases}\\n            (x^2)^{\\\\space \\\\frac{n}{2}}           & \\\\text{if n is even}  \\\\\\\\\\n            x \\\\space (x^2)^{\\\\space \\\\frac{n-1}{2}}    & \\\\text{if n is odd}   \\\\\\\\\\n            \\\\end{cases}\\n        \"]);return y=function(){return e},e}function w(){var e=v([\"\\n            base ^ {exponent} = \\n            \\begin{cases}\\n            (base^2)^{space \\frac{exponent}{2}}                 & \\text{if exponent is even}  \\\\\\n            base space (base^2)^{space \\frac{exponent-1}{2}}   & \\text{if exponent is odd}   \\\\\\n            end{cases}\\n        \"],[\"\\n            base ^ {exponent} = \\n            \\\\begin{cases}\\n            (base^2)^{\\\\space \\\\frac{exponent}{2}}                 & \\\\text{if exponent is even}  \\\\\\\\\\n            base \\\\space (base^2)^{\\\\space \\\\frac{exponent-1}{2}}   & \\\\text{if exponent is odd}   \\\\\\\\\\n            \\\\end{cases}\\n        \"]);return w=function(){return e},e}function v(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}t.default=function(){return r.a.createElement(\"div\",null,r.a.createElement(l.a,{gutterBottom:!0,variant:\"h5\"},r.a.createElement(o.a,{fontWeight:800},\"Definition\")),r.a.createElement(\"p\",null,\"This function will performe \",r.a.createElement(i.InlineMath,{math:\"base^{exponent}\"}),' but a lot faster; this will not do the obvious \"',r.a.createElement(i.InlineMath,{math:\"base * base * base * base ...\"}),'\" and so on',r.a.createElement(i.InlineMath,{math:\"exponent\"}),\" times but rather just \",r.a.createElement(i.InlineMath,{math:\"log(exponent)\"}),\" \",\"operations. This technique is called exponentiation by squaring.\"),r.a.createElement(\"p\",null,\"The idea is to see this way of expressing exponentiation:\"),r.a.createElement(i.BlockMath,null,String.raw(w())),r.a.createElement(\"p\",null,\"Or if you like small variable names we can say that \",r.a.createElement(i.InlineMath,{math:\"base = x\"}),\" and\",\" \",r.a.createElement(i.InlineMath,{math:\"exponent = n\"}),\":\"),r.a.createElement(i.BlockMath,null,String.raw(y())),r.a.createElement(g,{language:\"cpp\",fileName:\"BinaryExponentiation.cpp\",lines:[1,8]}),r.a.createElement(l.a,{gutterBottom:!0,variant:\"h5\"},r.a.createElement(o.a,{fontWeight:800},\"Simple Optimizations\")),r.a.createElement(\"p\",null,\"Now we want to eliminate the recursion and modify a little bit the idea:\"),r.a.createElement(\"ul\",null,r.a.createElement(\"li\",{style:{marginBottom:\"0.7rem\"}},r.a.createElement(\"p\",null,\"Instead of making a recursive function we will do an iterative function, to do this we use a while loop with the stop condition being the exponent equal to zero; this represents that we have made all the operations necessary so we can just safely return\",\" \",r.a.createElement(i.InlineMath,{math:\"solution\"}),\".\")),r.a.createElement(\"li\",{style:{marginBottom:\"0.7rem\"}},r.a.createElement(\"p\",null,\"In general the base in the next recursive call will be square of the current one, so we will do that.\")),r.a.createElement(\"li\",{style:{marginBottom:\"0.7rem\"}},r.a.createElement(\"p\",null,\"Also remember that \",r.a.createElement(i.InlineMath,{math:\"\\\\frac{exponent}{2}\"}),\" is doing a integer division, so in reality it is doing \",r.a.createElement(i.InlineMath,{math:\"\\\\lfloor \\\\frac{exponent}{2} \\\\rfloor\"}),\" and that is exaclty what we wanted because it handles correctly both cases, odd and even exponent.\")),r.a.createElement(\"li\",{style:{marginBottom:\"0.7rem\"}},r.a.createElement(\"p\",null,\"Now, the special part here is when the exponent is odd, in this case remember the expression \",r.a.createElement(i.InlineMath,{math:\"x^n = x \\\\space (x^2)^{\\\\space \\\\frac{n-1}{2}}\"}),\".\"),r.a.createElement(\"p\",null,\"So now, when we see an odd exponent we need to multiply the result of the next consecutive recursive calls by the current exponent, therefore need a place to store those bases, we are going to use \",r.a.createElement(i.InlineMath,{math:\"solution\"}),\" for that.\")),r.a.createElement(\"li\",null,r.a.createElement(\"p\",null,\"Finally you may be thinking the same thing as me: What would happen if we have a exponent of the form \",r.a.createElement(i.InlineMath,{math:\"2^n\"}),\", so there are never odd exponents and therefore we never update the solution?\"),r.a.createElement(\"p\",null,\"Well, remember that \",r.a.createElement(i.InlineMath,{math:\"2^3 = 8 = 1 * 8\"}),\", or more in general\",\" \",r.a.createElement(i.InlineMath,{math:\"2^n = 1 * 2^n\"}),\", so we will eventually update solution, when we reach \",r.a.createElement(i.InlineMath,{math:\"exponent = 1\"}),\".\"))),r.a.createElement(g,{language:\"cpp\",fileName:\"BinaryExponentiation.cpp\",lines:[10,22]}),r.a.createElement(l.a,{gutterBottom:!0,variant:\"h5\"},r.a.createElement(o.a,{fontWeight:800},\"Optimizations\")),r.a.createElement(l.a,{gutterBottom:!0,variant:\"subtitle1\"},r.a.createElement(o.a,{fontWeight:600},\"How to optimize \",r.a.createElement(i.InlineMath,{math:\"e = \\\\frac{e-1}{2}\"}),\" and\",\" \",r.a.createElement(i.InlineMath,{math:\"e = \\\\frac{e}{2}\"}))),r.a.createElement(\"p\",null,\"Remember the bitwise operations equalities:\"),r.a.createElement(\"ul\",null,r.a.createElement(\"li\",null,r.a.createElement(i.InlineMath,{math:\"x << y = x * 2^y\"})),r.a.createElement(\"li\",null,r.a.createElement(i.InlineMath,{math:\"x >> y = \\\\left \\\\lfloor \\\\dfrac{x}{2^y} \\\\right \\\\rfloor\"}))),r.a.createElement(\"p\",null,\"This optimizations are using the bitwise operations, that mean it is a lot faster that a division. note that many C++ compilers will to optimization automatically.\"),r.a.createElement(l.a,{gutterBottom:!0,variant:\"subtitle1\"},r.a.createElement(o.a,{fontWeight:600},\"Check in the exponent is odd or even\")),r.a.createElement(\"p\",null,\"To do this just do exponent & 1.\"),r.a.createElement(\"p\",null,\"For example the number \",r.a.createElement(i.InlineMath,{math:\"000101101010\"}),\" if the exponent was odd then the last digit will be 1, so exponent & 1 give true only if the last digit was 1.\"),r.a.createElement(\"p\",null,\"So now we arrive to the final implementation we use:\"),r.a.createElement(g,{language:\"cpp\",fileName:\"BinaryExponentiation.cpp\",lines:[24,36]}),r.a.createElement(l.a,{gutterBottom:!0,variant:\"h5\"},r.a.createElement(o.a,{fontWeight:800},\"Modular Exponentation\")),r.a.createElement(\"p\",null,\"This is to do \",r.a.createElement(i.InlineMath,{math:\"base^{exponent}  \\\\space \\\\space \\\\mod \\\\space n\"})),r.a.createElement(g,{language:\"cpp\",fileName:\"BinaryExponentiation.cpp\",lines:[38,52]}))}}}]);","extractedComments":[]}