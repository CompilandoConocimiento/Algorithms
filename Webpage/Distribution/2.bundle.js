(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{329:function(e,t,n){"use strict";n.r(t);var a=n(0),r=n.n(a),o=n(122),l=n(127),i=n(130),c=n(328),s=n(128),m=n(65),u=n(44),p=n(32),h=function(e){var t,n,a,r,o=(t=document.querySelector(".hljs-comment"))&&"none"===t.style.display?e.map((function(e){return e.split("//")[0]})):e;n=o.join("\n"),a=document.documentElement.scrollTop||document.body.scrollTop,(r=document.createElement("textarea")).value=n,document.body.appendChild(r),r.focus(),r.select(),document.execCommand("copy"),document.body.removeChild(r),scroll(0,a)},f=n(36);function d(){return(d=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function b(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function E(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function y(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var n=[],a=!0,r=!1,o=void 0;try{for(var l,i=e[Symbol.iterator]();!(a=(l=i.next()).done)&&(n.push(l.value),!t||n.length!==t);a=!0);}catch(e){r=!0,o=e}finally{try{a||null==i.return||i.return()}finally{if(r)throw o}}return n}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return x(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(n);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return x(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function x(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,a=new Array(t);n<t;n++)a[n]=e[n];return a}var g=function(e){var t=e.language,n=e.fileName,o=e.lines,l=Object(a.useContext)(u.CodeStyleContext),i=y(Object(a.useContext)(u.CodeDataContext),2),x=i[0],g=i[1],w=Object(a.useContext)(m.a),v=y(Object(a.useState)(!1),2),O=v[0],j=v[1];if(void 0===x[n])return g(n,w),r.a.createElement(p.b,null);var I=y(o,2),M=I[0],S=I[1],B=x[n].slice(M-1,S),C=Object(f.c)(l.style),z=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?b(Object(n),!0).forEach((function(t){E(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):b(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},f.a,{fontSize:l.fontSize});return r.a.createElement(r.a.Fragment,null,r.a.createElement(s.a,{anchorOrigin:{vertical:"bottom",horizontal:"left"},open:O,autoHideDuration:6e3,onClose:function(){return j(!1)},message:r.a.createElement("span",null,"Code copied to clipboard ;)")}),r.a.createElement(c.a,d({customStyle:z,language:t,style:C},{onDoubleClick:function(){j(!0),h(B)}}),B.join("\n")))};function w(){var e=O(["\n            x^n = \n            \begin{cases}\n            (x^2)^{space \frac{n}{2}}           & \text{if n is even}  \\\n            x space (x^2)^{space \frac{n-1}{2}}    & \text{if n is odd}   \\\n            end{cases}\n        "],["\n            x^n = \n            \\begin{cases}\n            (x^2)^{\\space \\frac{n}{2}}           & \\text{if n is even}  \\\\\n            x \\space (x^2)^{\\space \\frac{n-1}{2}}    & \\text{if n is odd}   \\\\\n            \\end{cases}\n        "]);return w=function(){return e},e}function v(){var e=O(["\n            base ^ {exponent} = \n            \begin{cases}\n            (base^2)^{space \frac{exponent}{2}}                 & \text{if exponent is even}  \\\n            base space (base^2)^{space \frac{exponent-1}{2}}   & \text{if exponent is odd}   \\\n            end{cases}\n        "],["\n            base ^ {exponent} = \n            \\begin{cases}\n            (base^2)^{\\space \\frac{exponent}{2}}                 & \\text{if exponent is even}  \\\\\n            base \\space (base^2)^{\\space \\frac{exponent-1}{2}}   & \\text{if exponent is odd}   \\\\\n            \\end{cases}\n        "]);return v=function(){return e},e}function O(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}t.default=function(){return r.a.createElement("div",null,r.a.createElement(o.a,{gutterBottom:!0,variant:"h5"},r.a.createElement(l.a,{fontWeight:800},"Definition")),r.a.createElement("p",null,"This function will performe ",r.a.createElement(i.InlineMath,{math:"base^{exponent}"}),' but a lot faster; this will not do the obvious "',r.a.createElement(i.InlineMath,{math:"base * base * base * base ..."}),'" and so on',r.a.createElement(i.InlineMath,{math:"exponent"})," times but rather just ",r.a.createElement(i.InlineMath,{math:"log(exponent)"})," ","operations. This technique is called exponentiation by squaring."),r.a.createElement("p",null,"The idea is to see this way of expressing exponentiation:"),r.a.createElement(i.BlockMath,null,String.raw(v())),r.a.createElement("p",null,"Or if you like small variable names we can say that ",r.a.createElement(i.InlineMath,{math:"base = x"})," and"," ",r.a.createElement(i.InlineMath,{math:"exponent = n"}),":"),r.a.createElement(i.BlockMath,null,String.raw(w())),r.a.createElement(g,{language:"cpp",fileName:"BinaryExponentiation.cpp",lines:[1,8]}),r.a.createElement(o.a,{gutterBottom:!0,variant:"h5"},r.a.createElement(l.a,{fontWeight:800},"Simple Optimizations")),r.a.createElement("p",null,"Now we want to eliminate the recursion and modify a little bit the idea:"),r.a.createElement("ul",null,r.a.createElement("li",{style:{marginBottom:"0.7rem"}},r.a.createElement("p",null,"Instead of making a recursive function we will do an iterative function, to do this we use a while loop with the stop condition being the exponent equal to zero; this represents that we have made all the operations necessary so we can just safely return"," ",r.a.createElement(i.InlineMath,{math:"solution"}),".")),r.a.createElement("li",{style:{marginBottom:"0.7rem"}},r.a.createElement("p",null,"In general the base in the next recursive call will be square of the current one, so we will do that.")),r.a.createElement("li",{style:{marginBottom:"0.7rem"}},r.a.createElement("p",null,"Also remember that ",r.a.createElement(i.InlineMath,{math:"\\frac{exponent}{2}"})," is doing a integer division, so in reality it is doing ",r.a.createElement(i.InlineMath,{math:"\\lfloor \\frac{exponent}{2} \\rfloor"})," and that is exaclty what we wanted because it handles correctly both cases, odd and even exponent.")),r.a.createElement("li",{style:{marginBottom:"0.7rem"}},r.a.createElement("p",null,"Now, the special part here is when the exponent is odd, in this case remember the expression ",r.a.createElement(i.InlineMath,{math:"x^n = x \\space (x^2)^{\\space \\frac{n-1}{2}}"}),"."),r.a.createElement("p",null,"So now, when we see an odd exponent we need to multiply the result of the next consecutive recursive calls by the current exponent, therefore need a place to store those bases, we are going to use ",r.a.createElement(i.InlineMath,{math:"solution"})," for that.")),r.a.createElement("li",null,r.a.createElement("p",null,"Finally you may be thinking the same thing as me: What would happen if we have a exponent of the form ",r.a.createElement(i.InlineMath,{math:"2^n"}),", so there are never odd exponents and therefore we never update the solution?"),r.a.createElement("p",null,"Well, remember that ",r.a.createElement(i.InlineMath,{math:"2^3 = 8 = 1 * 8"}),", or more in general"," ",r.a.createElement(i.InlineMath,{math:"2^n = 1 * 2^n"}),", so we will eventually update solution, when we reach ",r.a.createElement(i.InlineMath,{math:"exponent = 1"}),"."))),r.a.createElement(g,{language:"cpp",fileName:"BinaryExponentiation.cpp",lines:[10,22]}),r.a.createElement(o.a,{gutterBottom:!0,variant:"h5"},r.a.createElement(l.a,{fontWeight:800},"Optimizations")),r.a.createElement(o.a,{gutterBottom:!0,variant:"subtitle1"},r.a.createElement(l.a,{fontWeight:600},"How to optimize ",r.a.createElement(i.InlineMath,{math:"e = \\frac{e-1}{2}"})," and"," ",r.a.createElement(i.InlineMath,{math:"e = \\frac{e}{2}"}))),r.a.createElement("p",null,"Remember the bitwise operations equalities:"),r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement(i.InlineMath,{math:"x << y = x * 2^y"})),r.a.createElement("li",null,r.a.createElement(i.InlineMath,{math:"x >> y = \\left \\lfloor \\dfrac{x}{2^y} \\right \\rfloor"}))),r.a.createElement("p",null,"This optimizations are using the bitwise operations, that mean it is a lot faster that a division. note that many C++ compilers will to optimization automatically."),r.a.createElement(o.a,{gutterBottom:!0,variant:"subtitle1"},r.a.createElement(l.a,{fontWeight:600},"Check in the exponent is odd or even")),r.a.createElement("p",null,"To do this just do exponent & 1."),r.a.createElement("p",null,"For example the number ",r.a.createElement(i.InlineMath,{math:"000101101010"})," if the exponent was odd then the last digit will be 1, so exponent & 1 give true only if the last digit was 1."),r.a.createElement("p",null,"So now we arrive to the final implementation we use:"),r.a.createElement(g,{language:"cpp",fileName:"BinaryExponentiation.cpp",lines:[24,36]}),r.a.createElement(o.a,{gutterBottom:!0,variant:"h5"},r.a.createElement(l.a,{fontWeight:800},"Modular Exponentation")),r.a.createElement("p",null,"This is to do ",r.a.createElement(i.InlineMath,{math:"base^{exponent}  \\space \\space \\mod \\space n"})),r.a.createElement(g,{language:"cpp",fileName:"BinaryExponentiation.cpp",lines:[38,52]}))}}}]);